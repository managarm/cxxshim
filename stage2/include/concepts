#ifndef _CXXSHIM_CONCEPTS
#define _CXXSHIM_CONCEPTS

#ifdef CXXSHIM_INTEGRATE_GCC

#include_next <concepts>

#else // CXXSHIM_INTEGRATE_GCC

#include <type_traits>
#include <compare>

namespace std {

namespace detail {
	template< class T, class U >
	concept SameHelper = is_same_v<T, U>;
}

template<class T, class U>
concept same_as = detail::SameHelper<T, U> && detail::SameHelper<U, T>;

template<class Derived, class Base>
concept derived_from =
	is_base_of_v<Base, Derived> &&
	is_convertible_v<const volatile Derived*, const volatile Base*>;

template<class From, class To>
concept convertible_to =
	is_convertible_v<From, To> &&
	requires {
		static_cast<To>(declval<From>());
	};

// TODO: needs type_traits: common_reference_t

// template<class T, class U>
// concept common_reference_with =
// 	same_as<common_reference_t<T, U>, common_reference_t<U, T>> &&
// 	convertible_to<T, common_reference_t<T, U>> &&
// 	convertible_to<U, common_reference_t<T, U>>;

// TODO: needs type_traits: common_reference_t

// template<class T, class U>
// concept common_with =
// 	same_as<common_type_t<T, U>, common_type_t<U, T>> &&
// 	requires {
// 		static_cast<common_type_t<T, U>>(declval<T>());
// 		static_cast<common_type_t<T, U>>(declval<U>());
// 	} &&
// 	common_reference_with<
// 	add_lvalue_reference_t<const T>,
// 	add_lvalue_reference_t<const U>> &&
// 	common_reference_with<
// 	add_lvalue_reference_t<common_type_t<T, U>>,
// 	common_reference_t<
// 		add_lvalue_reference_t<const T>,
// 		add_lvalue_reference_t<const U>>>;

template<class T>
concept integral = is_integral_v<T>;

template<class T>
concept signed_integral = integral<T> && is_signed_v<T>;

template<class T>
concept unsigned_integral = integral<T> && !signed_integral<T>;

template<class T>
concept floating_point = is_floating_point_v<T>;

// TODO: needs type_traits: common_reference_t

// template<class LHS, class RHS>
// concept assignable_from =
// 	is_lvalue_reference_v<LHS> &&
// 	common_reference_with<
// 		const remove_reference_t<LHS>&,
// 		const remove_reference_t<RHS>&> &&
// 	requires(LHS lhs, RHS&& rhs) {
// 		{ lhs = forward<RHS>(rhs) } -> same_as<LHS>;
// 	};

template<class B>
concept __boolean_testable_impl = convertible_to<B, bool>;

template<class B>
concept boolean_testable = __boolean_testable_impl<B> &&
    requires (B&& b) {
        { !forward<B>(b) } -> __boolean_testable_impl;
    };

template<class T, class U>
concept __WeaklyEqualityComparableWith =
	requires(const remove_reference_t<T>& t,
			const remove_reference_t<U>& u) {
		{ t == u } -> boolean_testable;
		{ t != u } -> boolean_testable;
		{ u == t } -> boolean_testable;
		{ u != t } -> boolean_testable;
	};

template<class T>
concept equality_comparable = __WeaklyEqualityComparableWith<T, T>;

// TODO: needs type_traits: common_reference_t

// template<class T, class U>
// concept equality_comparable_with =
// 	equality_comparable<T> &&
// 	equality_comparable<U> &&
// 	common_reference_with<
// 		const remove_reference_t<T>&,
// 		const remove_reference_t<U>&> &&
// 	equality_comparable<
// 		common_reference_t<
// 		const remove_reference_t<T>&,
// 		const remove_reference_t<U>&>> &&
// 	__WeaklyEqualityComparableWith<T, U>;

// TODO: needs type_traits: common_reference_t

// template<class T, class U>
// concept totally_ordered_with =
// 	totally_ordered<T> &&
// 	totally_ordered<U> &&
// 	equality_comparable_with<T, U> &&
// 	totally_ordered<
// 		common_reference_t<
// 		const remove_reference_t<T>&,
// 		const remove_reference_t<U>&>> &&
// 	__PartiallyOrderedWith<T, U>;

template<class T, class U>
concept __PartiallyOrderedWith =      // exposition only
	requires(const remove_reference_t<T>& t,
			const remove_reference_t<U>& u) {
		{ t <  u } -> boolean_testable;
		{ t >  u } -> boolean_testable;
		{ t <= u } -> boolean_testable;
		{ t >= u } -> boolean_testable;
		{ u <  t } -> boolean_testable;
		{ u >  t } -> boolean_testable;
		{ u <= t } -> boolean_testable;
		{ u >= t } -> boolean_testable;
	};

template<class T>
concept totally_ordered = equality_comparable<T> && __PartiallyOrderedWith<T, T>;

template<class T, class Cat>
concept __ComparesAs = same_as<common_comparison_category_t<T, Cat>, Cat>;

template<class T, class Cat = partial_ordering>
concept three_way_comparable =
	__WeaklyEqualityComparableWith<T, T> &&
	__PartiallyOrderedWith<T, T> &&
	requires(const remove_reference_t<T>& a,
			const remove_reference_t<T>& b) {
		{ a <=> b } -> __ComparesAs<Cat>;
	};

// TODO: needs type_traits: common_reference_t

// template<class T, class U, class Cat = partial_ordering>
// concept three_way_comparable_with =
//   three_way_comparable<T, Cat> &&
//   three_way_comparable<U, Cat> &&
//   common_reference_with<
//     const remove_reference_t<T>&,
//     const remove_reference_t<U>&> &&
//   three_way_comparable<
//     common_reference_t<
//       const remove_reference_t<T>&,
//       const remove_reference_t<U>&>, Cat> &&
//   __WeaklyEqualityComparableWith<T, U> &&
//   __PartiallyOrderedWith<T, U> &&
//   requires(const remove_reference_t<T>& t,
//            const remove_reference_t<U>& u) {
//     { t <=> u } -> __ComparesAs<Cat>;
//     { u <=> t } -> __ComparesAs<Cat>;
//   };

template<class F, class... Args>
concept invocable =
	requires(F&& f, Args&&... args) {
		forward<F>(f)(forward<Args>(args)...);
	};

template<class F, class... Args>
concept regular_invocable = invocable<F, Args...>;

template <class F, class... Args>
concept predicate =
	regular_invocable<F, Args...> &&
	boolean_testable<invoke_result_t<F, Args...>>;

template<class R, class T, class U>
concept relation =
	predicate<R, T, T> && predicate<R, U, U> &&
	predicate<R, T, U> && predicate<R, U, T>;

template<class R, class T, class U>
concept equivalence_relation = relation<R, T, U>;

template<class R, class T, class U>
concept strict_weak_order = relation<R, T, U>;

} // namespace std

#endif // !defined(CXXSHIM_INTEGRATE_GCC)

#endif // _CXXSHIM_CONCEPTS