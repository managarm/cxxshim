#ifndef _CXXSHIM_TYPE_TRAITS
#define _CXXSHIM_TYPE_TRAITS

#ifdef CXXSHIM_INTEGRATE_GCC

#include_next <type_traits>

#else // CXXSHIM_INTEGRATE_GCC

#include <cstddef>

namespace std {

template<class T> struct remove_cv { typedef T type; };
template<class T> struct remove_cv<const T> { typedef T type; };
template<class T> struct remove_cv<volatile T> { typedef T type; };
template<class T> struct remove_cv<const volatile T> { typedef T type; };

template<class T>
using remove_cv_t = typename remove_cv<T>::type;

template<class T> struct add_cv { typedef const volatile T type; };

template<class T>
using add_cv_t = typename add_cv<T>::type;

template<class T, T v>
struct integral_constant {
	static constexpr T value = v;
	using value_type = T;
	using type = integral_constant;

	constexpr operator value_type() const noexcept {
		return value;
	}

	constexpr value_type operator()() const noexcept {
		return value;
	}
};

template<bool v>
using bool_constant = integral_constant<bool, v>;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

#define _DEFINE_SPEC0(_Name, _Type, _Value) \
	template<> \
	struct _Name<_Type> \
	: public integral_constant<bool, _Value> { }

namespace detail {
	template<typename T>
	struct is_integral_helper : integral_constant<bool, false> { };

	_DEFINE_SPEC0(is_integral_helper, bool, true);
	_DEFINE_SPEC0(is_integral_helper, char, true);
	_DEFINE_SPEC0(is_integral_helper, signed char, true);
	_DEFINE_SPEC0(is_integral_helper, unsigned char, true);
	_DEFINE_SPEC0(is_integral_helper, short, true);
	_DEFINE_SPEC0(is_integral_helper, unsigned short, true);
	_DEFINE_SPEC0(is_integral_helper, int, true);
	_DEFINE_SPEC0(is_integral_helper, unsigned int, true);
	_DEFINE_SPEC0(is_integral_helper, long, true);
	_DEFINE_SPEC0(is_integral_helper, unsigned long, true);
	_DEFINE_SPEC0(is_integral_helper, long long, true);
	_DEFINE_SPEC0(is_integral_helper, unsigned long long, true);
} // namespace detail

template<typename T>
struct is_integral : detail::is_integral_helper<typename remove_cv<T>::type> { };

template<typename T>
inline constexpr bool is_integral_v = is_integral<T>::value;

namespace detail {
	template<typename T>
	struct is_floating_point_helper : integral_constant<bool, false> { };

	_DEFINE_SPEC0(is_floating_point_helper, float, true);
	_DEFINE_SPEC0(is_floating_point_helper, double, true);
	_DEFINE_SPEC0(is_floating_point_helper, long double, true);
} // namespace detail

template<typename T>
struct is_floating_point : detail::is_floating_point_helper<typename remove_cv<T>::type> { };

template<typename T>
inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

#undef _DEFINE_SPEC0

template<typename T>
struct is_arithmetic : public integral_constant<bool, is_integral<T>::value ||
				is_floating_point<T>::value> { };

namespace detail {
	template<typename T, bool = is_arithmetic<T>::value>
	struct is_unsigned : public integral_constant<bool, T(0) < T(-1)> { };

	template<typename T>
	struct is_unsigned<T, false> : public false_type { };

	template<typename T, bool = is_arithmetic<T>::value>
	struct is_signed : public integral_constant<bool, T(-1) < T(0)> { };

	template<typename T>
	struct is_signed<T, false> : public false_type { };

	template<typename T>
	struct type_identity { using type = T; };

	template<typename T>
	auto try_add_lvalue_reference(int) -> type_identity<T&>;
	template<typename T>
	auto try_add_lvalue_reference(...) -> type_identity<T>;

	template<typename T>
	auto try_add_rvalue_reference(int) -> type_identity<T&&>;
	template<typename T>
	auto try_add_rvalue_reference(...) -> type_identity<T>;

	template<typename T> struct make_unsigned { };
	template<> struct make_unsigned<char> { using type = unsigned char; };
	template<> struct make_unsigned<signed char> { using type = unsigned char; };
	template<> struct make_unsigned<unsigned char> { using type = unsigned char; };
	template<> struct make_unsigned<short> { using type = unsigned short; };
	template<> struct make_unsigned<unsigned short> { using type = unsigned short; };
	template<> struct make_unsigned<int> { using type = unsigned int; };
	template<> struct make_unsigned<unsigned int> { using type = unsigned int; };
	template<> struct make_unsigned<long> { using type = unsigned long; };
	template<> struct make_unsigned<unsigned long> { using type = unsigned long; };
	template<> struct make_unsigned<long long> { using type = unsigned long long; };
	template<> struct make_unsigned<unsigned long long> { using type = unsigned long long; };
} // namespace detail

template<typename T>
struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) { };
template<typename T>
using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;

template<typename T>
struct add_rvalue_reference : decltype(detail::try_add_rvalue_reference<T>(0)) { };
template<typename T>
using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;

template<typename T>
struct make_unsigned : detail::make_unsigned<T> { };
template<typename T>
using make_unsigned_t = typename make_unsigned<T>::type;

template<typename T>
struct is_unsigned : public detail::is_unsigned<T>::type { };

template<class T>
inline constexpr bool is_unsigned_v = is_unsigned<T>::value;

template<typename T>
struct is_signed : public detail::is_signed<T>::type { };

template<class T>
inline constexpr bool is_signed_v = is_signed<T>::value;

template<class T, class U>
struct is_same : false_type { };

template<class T>
struct is_same<T, T> : true_type { };

template<class T, class U>
inline constexpr bool is_same_v = is_same<T, U>::value;

template<class T>
struct is_void : is_same<T, void> { };

template<class T>
inline constexpr bool is_void_v = is_void<T>::value;

template<class T>
struct is_null_pointer : is_same<nullptr_t, remove_cv_t<T>> { };

template<class T>
inline constexpr bool is_null_pointer_v = is_null_pointer<T>::value;

template<class T> struct is_const : false_type { };
template<class T> struct is_const<const T> : true_type { };

template<class T>
inline constexpr bool is_const_v = is_const<T>::value;

template<class T> struct is_reference : false_type { };
template<class T> struct is_reference<T&> : true_type { };
template<class T> struct is_reference<T&&> : true_type { };

template<class T>
inline constexpr bool is_reference_v = is_reference<T>::value;

template<typename T>
add_rvalue_reference_t<T> declval();

template<typename T>
struct remove_reference {
	typedef T type;
};

template<typename T>
struct remove_reference<T &> {
	typedef T type;
};

template<typename T>
struct remove_reference<T &&> {
	typedef T type;
};

template<typename T>
using remove_reference_t = typename remove_reference<T>::type;

template<class T> struct remove_const { typedef T type; };
template<class T> struct remove_const<const T> { typedef T type; };

template<class T>
using remove_const_t = typename remove_const<T>::type;

template<class T> struct remove_volatile { typedef T type; };
template<class T> struct remove_volatile<volatile T> { typedef T type; };

template<class T>
using remove_volatile_t = typename remove_volatile<T>::type;

template<class T> struct add_const { typedef const T type; };

template<class T>
using add_const_t = typename add_const<T>::type;

template<class T> struct add_volatile { typedef volatile T type; };

template<class T>
using add_volatile_t = typename add_volatile<T>::type;

namespace detail {
	template<typename... T>
	struct _void_impl_helper {
		using type = void;
	};
} // namespace detail

template<typename... T>
using void_t = typename detail::_void_impl_helper<T...>::type;

template<typename T>
struct add_pointer {
	using type = T *;
};

template<typename T>
using add_pointer_t = typename add_pointer<T>::type;

template<class T> struct remove_pointer { using type = T; };
template<class T> struct remove_pointer<T *> { using type = T; };
template<class T> struct remove_pointer<T * const> { using type = T; };
template<class T> struct remove_pointer<T * volatile> { using type = T; };
template<class T> struct remove_pointer<T * const volatile> { using type = T; };

template<typename T>
using remove_pointer_t = typename remove_pointer<T>::type;

namespace detail {
	template<bool, typename F, typename... Args>
	struct _invoke_result_impl_helper { };

	template<typename F, typename... Args>
	concept is_invokable_with = requires (F f, Args ...args) {
		f(static_cast<Args &&>(args)...);
	};

	template<typename F, typename... Args>
	struct _invoke_result_impl_helper<true, F, Args...> {
		using type = decltype(declval<F>() (declval<Args>()...));
	};
} // namespace detail

template<class F, class... ArgTypes>
struct invoke_result {
	using type = typename detail::_invoke_result_impl_helper<
			detail::is_invokable_with<F, ArgTypes...>,
			F, ArgTypes...>::type;
};

template<class F, class... ArgTypes>
using invoke_result_t = typename invoke_result<F, ArgTypes...>::type;

template<class F, class... ArgTypes>
struct is_invocable;

template<class F, class... ArgTypes>
requires detail::is_invokable_with<F, ArgTypes...>
struct is_invocable<F, ArgTypes...> : true_type { };

template<class F, class... ArgTypes>
requires (!detail::is_invokable_with<F, ArgTypes...>)
struct is_invocable<F, ArgTypes...> : false_type { };

template<class F, class... ArgTypes>
inline constexpr bool is_invocable_v = is_invocable<F, ArgTypes...>::value;

template<bool B, class T = void>
struct enable_if { };

template<class T>
struct enable_if<true, T> { typedef T type; };

template<bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type;

template<class T, class... Args>
struct is_constructible : bool_constant<__is_constructible(T, Args...)> { };

template<class T, class... Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(T, Args...)> { };

template<class T>
struct is_trivially_default_constructible : is_trivially_constructible<T> { };

template<class T>
inline constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<T>::value;

template<class T>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(T)> { };

namespace detail {
	template<bool, class T, class... Args>
	struct is_nt_constructible_impl : false_type { };

	template<class T, class... Args>
	struct is_nt_constructible_impl<true, T, Args...> : bool_constant<noexcept(T(declval<Args>()...))> { };

	template<class T>
	struct is_nt_constructible_impl<true, T> : bool_constant<noexcept(T())> { };

	template<class T, class... Args>
	struct is_nt_constructible : is_nt_constructible_impl<is_constructible<T, Args...>::value, T, Args...> { };
} // namespace detail

template<class T, class... Args>
struct is_nothrow_constructible : detail::is_nt_constructible<T, Args...> { };

template<class T>
struct is_nothrow_default_constructible : detail::is_nt_constructible<T> { };

namespace detail {
	struct do_is_destructible_impl {
		template<typename T, typename = decltype(declval<T&>().~_T())>
		static true_type __test(int);

		template<typename>
		static false_type __test(...);
	};

	template<class T>
	struct is_destructible_impl : do_is_destructible_impl {
		using type = decltype(__test<T>(0));
	};
} // namespace detail

template<class T>
struct is_destructible : detail::is_destructible_impl<T>::type { };

template<class T>
struct is_trivially_destructible : bool_constant<
#if defined(__clang__) && __clang_major__ >= 15
		__is_trivially_destructible(T)
#else
		__has_trivial_destructor(T)
#endif
	> { };

template<class T, class... Args>
inline constexpr bool is_constructible_v = is_constructible<T, Args...>::value;

template<class T, class... Args>
inline constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;

template<class T>
inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;

template<class T>
inline constexpr bool is_destructible_v = is_destructible<T>::value;

template<class T>
inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;

template<class T>
struct is_trivially_copy_constructible :
	is_trivially_constructible<T, typename add_lvalue_reference<
	typename add_const<T>::type>::type> { };

template<class T>
inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<T>::value;

template<class T>
struct is_trivially_move_constructible :
	is_trivially_constructible<T, typename add_rvalue_reference<T>::type> { };

template<class T>
inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<T>::value;

template<class T>
struct is_default_constructible : is_constructible<T> { };

template<class T>
struct is_copy_constructible :
	is_constructible<T, typename add_lvalue_reference<
	typename add_const<T>::type>::type> { };

template<class T>
inline constexpr bool is_copy_constructible_v = is_copy_constructible<T>::value;

template<class T>
struct is_move_constructible :
	is_constructible<T, typename add_rvalue_reference<T>::type> { };

template<class T>
inline constexpr bool is_move_constructible_v = is_move_constructible<T>::value;

template<class T>
inline constexpr bool is_default_constructible_v = is_default_constructible<T>::value;

template<class T>
inline constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<T>::value;

template<class T, typename U>
struct is_assignable : bool_constant<__is_assignable(T, U)> { };

template<class T>
struct is_move_assignable : is_assignable<
	typename add_lvalue_reference<T>::type,
	typename add_rvalue_reference<T>::type> { };

template<class T>
struct is_copy_assignable : is_assignable<
	typename add_lvalue_reference<T>::type,
	typename add_lvalue_reference<const T>::type> { };

template<class T, class U>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(T, U)> { };

template<class T>
struct is_trivially_move_assignable : is_trivially_assignable<
	typename add_lvalue_reference<T>::type,
	typename add_rvalue_reference<T>::type> { };

template<class T>
struct is_trivially_copy_assignable : is_trivially_assignable<
	typename add_lvalue_reference<T>::type,
	typename add_lvalue_reference<const T>::type> { };

template<class T, class U>
inline constexpr bool is_assignable_v = is_trivially_assignable<T, U>::value;

template<class T>
inline constexpr bool is_move_assignable_v = is_move_assignable<T>::value;

template<class T>
inline constexpr bool is_copy_assignable_v = is_copy_assignable<T>::value;

template<class T, class U>
inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;

template<class T>
inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;

template<class T>
inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<T>::value;

template<bool B, class T, class F>
struct conditional { typedef T type; };

template<class T, class F>
struct conditional<false, T, F> { typedef F type; };

template<bool B, typename T, typename F>
using conditional_t = typename conditional<B, T, F>::type;

template<class T>
struct is_array : false_type { };

template<class T>
struct is_array<T[]> : true_type { };

template<class T, size_t N>
struct is_array<T[N]> : true_type { };

template<class T>
inline constexpr bool is_array_v = is_array<T>::value;

namespace detail {
	template<class T>
	struct is_pointer_helper : false_type { };

	template<class T>
	struct is_pointer_helper<T *> : true_type { };
} // namespace detail

template<class T>
struct is_pointer : detail::is_pointer_helper<typename remove_cv<T>::type> { };

template<class T>
inline constexpr bool is_pointer_v = is_pointer<T>::value;

template<class T>
struct remove_extent { typedef T type; };

template<class T>
struct remove_extent<T[]> { typedef T type; };

template<class T, size_t N>
struct remove_extent<T[N]> { typedef T type; };

template<class T>
struct remove_all_extents { typedef T type;};

template<class T>
struct remove_all_extents<T[]> {
    typedef typename remove_all_extents<T>::type type;
};

template<class T, size_t N>
struct remove_all_extents<T[N]> {
    typedef typename remove_all_extents<T>::type type;
};

template<class T>
using remove_all_extents_t = typename remove_all_extents<T>::type;

template<class T>
struct is_function : integral_constant<
		bool,
		!is_const<const T>::value && !is_reference<T>::value
	> { };

template<class T>
struct is_enum : bool_constant<__is_enum(T)> { };

template<class T>
inline constexpr bool is_enum_v = is_enum<T>::value;

template<class T>
struct is_union : integral_constant<bool, __is_union(T)> { };

template<class T>
inline constexpr bool is_union_v = is_union<T>::value;

namespace detail {
	template<class T>
	integral_constant<bool, !is_union<T>::value> test(int T::*);

	template<class>
	false_type test(...);
} // namespace detail

template<class T>
struct is_class : decltype(detail::test<T>(nullptr)) { };

template<class T> struct is_lvalue_reference : false_type { };
template<class T> struct is_lvalue_reference<T&> : true_type { };

template<class T>
inline constexpr bool is_lvalue_reference_v = is_lvalue_reference<T>::value;

template<class T> struct is_rvalue_reference : false_type { };
template<class T> struct is_rvalue_reference<T&&> : true_type { };

template<class T>
inline constexpr bool is_rvalue_reference_v = is_rvalue_reference<T>::value;

template<class T>
struct is_member_function_pointer_helper : false_type { };

template<class T, class U>
struct is_member_function_pointer_helper<T U::*> : is_function<T> { };

template<class T>
struct is_member_function_pointer : is_member_function_pointer_helper< typename remove_cv<T>::type> { };

template<class T>
struct is_member_pointer_helper : false_type { };

template<class T, class U>
struct is_member_pointer_helper<T U::*> : true_type { };

template<class T>
struct is_member_pointer : is_member_pointer_helper<typename remove_cv<T>::type> { };

template<class T>
struct is_member_object_pointer : integral_constant<
		bool,
		is_member_pointer<T>::value &&
		!is_member_function_pointer<T>::value
	> { };

template<class T>
inline constexpr bool is_member_object_pointer_v = is_member_object_pointer<T>::value;

template<class T>
struct is_fundamental : integral_constant<
        bool,
        is_arithmetic<T>::value ||
        is_void<T>::value  ||
        is_null_pointer<T>::value
	> { };

template<class T>
inline constexpr bool is_fundamental_v = is_fundamental<T>::value;

template<class T>
struct is_scalar : integral_constant<bool,
		is_arithmetic<T>::value     ||
		is_enum<T>::value           ||
		is_pointer<T>::value        ||
		is_member_pointer<T>::value ||
		is_null_pointer<T>::value
	> { };

template<class T>
inline constexpr bool is_scalar_v = is_scalar<T>::value;

template<class T>
struct is_object : integral_constant<bool,
		is_scalar<T>::value ||
		is_array<T>::value  ||
		is_union<T>::value  ||
		is_class<T>::value
	> { };

template<class T>
inline constexpr bool is_object_v = is_object<T>::value;

template<class T>
struct is_compound : integral_constant<bool, !is_fundamental<T>::value> { };

template<class T>
inline constexpr bool is_compound_v = is_compound<T>::value;

template<class T> struct is_volatile : false_type { };
template<class T> struct is_volatile<volatile T> : true_type { };

template<class T>
inline constexpr bool is_volatile_v = is_volatile<T>::value;

template<class T>
struct is_trivial : integral_constant<
		bool,
		is_trivially_copyable<T>::value &&
		is_trivially_default_constructible<T>::value
	> { };

template<class T>
inline constexpr bool is_trivial_v = is_trivial<T>::value;

template<class T>
struct is_standard_layout : integral_constant<bool, __is_standard_layout(T)> { };

template<class T>
inline constexpr bool is_standard_layout_v = is_standard_layout<T>::value;

template<class T>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<T>>
    )> { };

template<class T>
inline constexpr bool has_unique_object_representations_v = has_unique_object_representations<T>::value;

template<class T>
struct is_empty : public integral_constant<bool, __is_empty(T)> { };

template<class T>
inline constexpr bool is_empty_v = is_empty<T>::value;

namespace detail {
	template<class T>
	true_type detect_is_polymorphic(
		decltype(dynamic_cast<const volatile void*>(static_cast<T*>(nullptr)))
	);
	template<class T>
	false_type detect_is_polymorphic(...);
} // namespace detail

template <class T>
struct is_polymorphic : decltype(detail::detect_is_polymorphic<T>(nullptr)) { };

template<class T>
inline constexpr bool is_polymorphic_v = is_polymorphic<T>::value;

template<class T>
struct is_abstract : public integral_constant<bool, __is_abstract(T)> { };

template<class T>
inline constexpr bool is_abstract_v = is_abstract<T>::value;

template<class T>
struct is_final : public integral_constant<bool, __is_final(T)> { };

template<class T>
inline constexpr bool is_final_v = is_final<T>::value;

template<class T>
struct is_aggregate : bool_constant<__is_aggregate(remove_cv_t<T>)> { };

template<class T>
inline constexpr bool is_aggregate_v = is_aggregate<T>::value;

template<class T>
struct is_bounded_array: false_type { };

template<class T, size_t N>
struct is_bounded_array<T[N]> : true_type { };

template<class T>
inline constexpr bool is_bounded_array_v = is_bounded_array<T>::value;

template<class T>
struct is_unbounded_array: false_type { };

template<class T>
struct is_unbounded_array<T[]> : true_type { };

template<class T>
inline constexpr bool is_unbounded_array_v = is_unbounded_array<T>::value;

template<class...> struct conjunction : true_type { };
template<class B1> struct conjunction<B1> : B1 { };
template<class B1, class... Bn>
struct conjunction<B1, Bn...> : conditional_t<bool(B1::value), conjunction<Bn...>, B1> { };

template<class... B>
inline constexpr bool conjunction_v = conjunction<B...>::value;

template<class...> struct disjunction : false_type { };
template<class B1> struct disjunction<B1> : B1 { };
template<class B1, class... Bn>
struct disjunction<B1, Bn...> : conditional_t<bool(B1::value), B1, disjunction<Bn...>>  { };

template<class... B>
inline constexpr bool disjunction_v = disjunction<B...>::value;

template<class B>
struct negation : bool_constant<!bool(B::value)> { };

template<class B>
inline constexpr bool negation_v = negation<B>::value;

namespace detail {
	namespace { // avoid ODR-violation
		template<class T>
		auto test_sizable(int) -> decltype(sizeof(T), true_type { });

		template<class>
		auto test_sizable(...) -> false_type;

		template<class T>
		auto test_nonconvertible_to_int(int) -> decltype(static_cast<false_type (*)(int)>(nullptr)(declval<T>()));

		template<class>
		auto test_nonconvertible_to_int(...) -> true_type;

		template<class T>
		constexpr bool is_scoped_enum_impl = conjunction_v<
			decltype(test_sizable<T>(0)),
			decltype(test_nonconvertible_to_int<T>(0))
		>;
	} // namespace
} // namespace detail

template<class>
struct is_scoped_enum : false_type { };

template<class E> requires is_enum_v<E>
struct is_scoped_enum<E> : bool_constant<detail::is_scoped_enum_impl<E>> { };

template<class T>
inline constexpr bool is_scoped_enum_v = is_scoped_enum<T>::value;

template<class T>
struct alignment_of : integral_constant<
		size_t,
		alignof(T)
	> { };

template<class T>
inline constexpr size_t alignment_of_v = alignment_of<T>::value;

template<class T>
struct rank : public integral_constant<size_t, 0> { };

template<class T>
struct rank<T[]> : public integral_constant<size_t, rank<T>::value + 1> { };

template<class T, size_t N>
struct rank<T[N]> : public integral_constant<size_t, rank<T>::value + 1> { };

template<class T>
inline constexpr size_t rank_v = rank<T>::value;

template<class T, unsigned N = 0>
struct extent : integral_constant<size_t, 0> { };

template<class T>
struct extent<T[], 0> : integral_constant<size_t, 0> { };

template<class T, unsigned N>
struct extent<T[], N> : extent<T, N-1> { };

template<class T, size_t I>
struct extent<T[I], 0> : integral_constant<size_t, I> { };

template<class T, size_t I, unsigned N>
struct extent<T[I], N> : extent<T, N-1> { };

template<class T, unsigned N = 0>
inline constexpr size_t extent_v = extent<T, N>::value;

namespace detail {
    template<typename B>
    true_type test_pre_ptr_convertible(const volatile B*);
    template<typename>
    false_type test_pre_ptr_convertible(const volatile void*);

    template<typename, typename>
    auto test_pre_is_base_of(...) -> true_type;
    template<typename B, typename D>
    auto test_pre_is_base_of(int) ->
        decltype(test_pre_ptr_convertible<B>(static_cast<D*>(nullptr)));
} // namespace detail

template<typename Base, typename Derived>
struct is_base_of :
    integral_constant<
        bool,
        is_class<Base>::value && is_class<Derived>::value &&
        decltype(detail::test_pre_is_base_of<Base, Derived>(0))::value
    > { };

template<class Base, class Derived>
inline constexpr bool is_base_of_v = is_base_of<Base, Derived>::value;

namespace detail {
	template<class T>
	auto test_returnable(int) -> decltype(
		void(static_cast<T(*)()>(nullptr)), true_type{ }
	);
	template<class>
	auto test_returnable(...) -> false_type;

	template<class From, class To>
	auto test_implicitly_convertible(int) -> decltype(
		void(declval<void(&)(To)>()(declval<From>())), true_type{ }
	);
	template<class, class>
	auto test_implicitly_convertible(...) -> false_type;
} // namespace detail

template<class From, class To>
struct is_convertible : integral_constant<bool,
		(decltype(detail::test_returnable<To>(0))::value &&
		decltype(detail::test_implicitly_convertible<From, To>(0))::value) ||
		(is_void<From>::value && is_void<To>::value)
	> { };

template<class From, class To>
inline constexpr bool is_convertible_v = is_convertible<From, To>::value;

template<class From, class To>
struct is_nothrow_convertible : conjunction<is_void<From>, is_void<To>> { };

template<class From, class To>
    requires
        requires {
            static_cast<To(*)()>(nullptr);
            { declval<void(&)(To) noexcept>()(declval<From>()) } noexcept;
        }
struct is_nothrow_convertible<From, To> : true_type { };

template<class From, class To>
inline constexpr bool is_nothrow_convertible_v = is_nothrow_convertible<From, To>::value;

namespace detail
{
	template<size_t Len>
	struct default_alignment
	{
		union type
		{
			unsigned char data[Len];
			struct __attribute__((aligned)) { } align;
		};
	};
} // namespace detail

template<size_t Len, size_t Align = alignof(typename detail::default_alignment<Len>::type)>
struct aligned_storage {
    struct type {
        alignas(Align) unsigned char data[Len];
    };
};

template<size_t Len, size_t Align = alignof(typename detail::default_alignment<Len>::type)>
using aligned_storage_t = typename aligned_storage<Len, Align>::type;

template<size_t Len, class... Types>
struct aligned_union
{
    static constexpr size_t alignment_value = max({alignof(Types)...});

    struct type
    {
      alignas(alignment_value) char _s[max({ Len, sizeof(Types)... })];
    };
};

template<size_t Len, class... Types>
using aligned_union_t = typename aligned_union<Len,Types...>::type;

template<class T>
struct decay {
private:
	typedef typename remove_reference<T>::type U;
public:
	typedef typename conditional<
		is_array<U>::value,
		typename remove_extent<U>::type*,
		typename conditional<
			is_function<U>::value,
		typename add_pointer<U>::type,
		typename remove_cv<U>::type
			>::type
	>::type type;
};

template<class T>
using decay_t = typename decay<T>::type;

template<class T>
struct remove_cvref {
    typedef remove_cv_t<remove_reference_t<T>> type;
};

template<class T>
using remove_cvref_t = typename remove_cvref<T>::type;

constexpr bool is_constant_evaluated()
{
#if __cpp_if_consteval >= 202106L
    if consteval { return true; } else { return false; }
#elif __cplusplus >= 201103L && __has_builtin(__builtin_is_constant_evaluated)
    return __builtin_is_constant_evaluated();
#endif
    return false;
}

// primary template (used for zero types)
template<class...>
struct common_type { };

// one type
template<class T>
struct common_type<T> : common_type<T, T> { };

// two types
template<class T1, class T2>
using cond_t = decltype(false ? declval<T1>() : declval<T2>());

template<class T1, class T2, class=void>
struct common_type_2_impl { };

template<class T1, class T2>
struct common_type_2_impl<T1, T2, void_t<cond_t<T1, T2>>> {
	using type = typename decay<cond_t<T1, T2>>::type;
};

template<class T1, class T2>
struct common_type<T1, T2>
: common_type_2_impl<typename decay<T1>::type,
	typename decay<T2>::type>
{ };

// 3+ types
template<class AlwaysVoid, class T1, class T2, class...R>
struct common_type_multi_impl { };

template<class T1, class T2, class...R>
struct common_type_multi_impl<
void_t<typename common_type<T1, T2>::type>, T1, T2, R...>
: common_type<typename common_type<T1, T2>::type, R...> { };


template<class T1, class T2, class... R>
struct common_type<T1, T2, R...>
: common_type_multi_impl<void, T1, T2, R...> { };

template<class... T>
using common_type_t = typename common_type<T...>::type;

template<class... T>
struct common_reference;

// If sizeof...(T) == 0
template<>
struct common_reference<> { };

// If sizeof...(T) == 1
template<class T>
struct common_reference<T> { using type = T; };

// If sizeof...(T) == 2
// TODO

// If sizeof...(T) > 2
// TODO

template<class... T>
using common_reference_t = typename common_reference<T...>::type;

template<class T, class U, template<class> class TQual, template<class> class UQual>
struct basic_common_reference { };

namespace detail {
	template<bool, typename>
	struct underlying_type_helper { };

	template<typename T>
	struct underlying_type_helper<true, T> {
		using type = __underlying_type(T);
	};
} // namespace detail

template<typename T>
struct underlying_type : detail::underlying_type_helper<
		is_enum_v<T>,
		T
	> { };

template<typename T>
using underlying_type_t = typename underlying_type<T>::type;

} // namespace std

#endif // !defined(CXXSHIM_INTEGRATE_GCC)

#endif // _CXXSHIM_TYPE_TRAITS
