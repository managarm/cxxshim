#ifndef _CXXSHIM_MEMORY
#define _CXXSHIM_MEMORY

#include <stddef.h>

namespace std {

template <class T>
T *addressof(const T &&) noexcept = delete;

template <class T>
T *addressof(T &r) noexcept {
#if defined(__has_builtin) && __has_builtin(__builtin_addessof)
        // clang __builtin_addessof language extension
        // XXX: also gcc >= 7.0 supports it, but older <10 versions don't support
        // __has_builtin macro
	return __buitin_addressof(r);
#else
	return reinterpret_cast<T *>(const_cast<char *>(&reinterpret_cast<const volatile char &>(r)));
#endif // !defined(__has_builtin)
}

template<typename Type>
struct allocator
{
	using value_type = Type;
	using pointer = Type*;
	using const_pointer = const Type*;
	using reference = Type&;
	using const_reference = const Type&;
	using size_type = size_t;
	using difference_type = ptrdiff_t;

	[[nodiscard]] constexpr Type *allocate(size_t size)
	{
		return static_cast<Type*>(::operator new(size * sizeof(Type)));
	}

	constexpr void deallocate(Type *ptr, size_t = 0)
	{
		::operator delete(ptr);
	}

	friend constexpr bool operator==(const allocator &, const allocator &) noexcept
	{
		return true;
	}
};

} // namespace std

#endif // _CXXSHIM_MEMORY
